---
layout: default
title: 기본 연산자
description: Basic Operators
parent: Swift 안내서
nav_order: 2
---

# 기본 연산자

{: .no_toc }

<details markdown="block">
  <summary>
    목차
  </summary>
  {: .text-delta }
1. TOC
{:toc}
</details>

---

**연산자**는 값들을 검사하고, 변경하고, 결합하는 데 쓰는 특별한 기호나 구절을 말합니다. 예를 들어 덧셈 연산자(`+`)는 `let i = 1 + 2`처럼 두 수를 더하며, 논리 AND 연산자(`&&`)는 `if enteredDoorCode && passsedRetinaScan`처럼 두 불 값을 결합합니다.

Swift는 C와 같은 언어가 가지고 있는 연산자들을 기본적으로 지원할 뿐 아니라 흔하게 등장하는 오류를 줄이기 위해 특징을 더 개선하였습니다. 할당 연산자(`=`)는 값을 반환하지 않습니다. 그리하여 동등 연산자(`==`) 대신 실수로 할당 연산자를 사용하는 것을 막습니다. 산술 연산자(`+`, `-`, `*`, `/`, `%` 등)는 값이 오버플로우하는 것을 감지하고 제한합니다. 이로써 해당 자료형이 저장할 수 있는 값보다 크거나 작은 수를 다루는 과정에서 예상과 다른 결과는 나오지 않게 됩니다. Swift의 오버플로우 연산자를 사용하면 값의 오버플로우 동작을 설정할 수 있습니다. [오버플로우 연산자](advanced-operators.md#오버플로우-연산자)에 자세히 나와 있습니다.

Swift는 또한 C에는 없는 범위 연산자를 제공합니다. `a..<b`와 `a...b`는 값의 범위를 간단히 표현할 수 있습니다.

이 장에서는 Swift에서 자주 쓰이는 연산자를 소개하고 있습니다. [고급 연산자](advanced-operators.md)는 Swift의 고급 연산자를 다루고 있으며, 커스텀 연산자를 어떻게 정의하고 커스텀 자료형에서 표준 자료형을 어떻게 구현하는지 설명하고 있습니다.

## 용어

연산자는 단항, 이항, 삼항 연산자로 구분됩니다.

* **단항** 연산자는 (`-a`처럼) 대상 하나에 대해 연산을 수행합니다. 단항 **전위** 연산자는 (`!b`처럼) 대상 바로 앞에 작성하고 단항 **후위** 연산자는 (`c!`처럼) 대상 바로 뒤에 작성합니다.
* **이항** 연산자는 (`2 + 3`처럼) 두 개의 대상에 대해 연산을 수행합니다. 두 대상 사이에 작성하므로 **중위** 연산자라고 부릅니다.
* **삼항** 연산자는 세 개의 대상에 대해 연산을 수행합니다. C와 마찬가지로 Swift에도 삼항 연산자는 삼한 조건 연산자(`a ? b : c`) 하나만 있습니다.

연산자가 연산을 수행하는 대상을 **피연산자**라고 합니다. 표현식 `1 + 2`에서는 `+` 기호가 이항 연산자이고 그에 대한 두 개의 피연산자가 `1`과 `2`인 것입니다.

## 할당 연산자

**할당 연산자**(`a = b`)는 `a`의 값을 `b`의 값으로 초기화하거나 업데이트합니다.

```swift
let b = 10
var a = 5
a = b
// 이제 a는 10과 같습니다.
```

할당 연산자의 우변이 여러 개의 값을 가진 튜플인 경우에는 그 원소들이 한 번에 여러 상수나 변수로 분해될 수 있습니다.

```swift
let (x, y) = (1, 2)
// x는 1과 같으며 y는 2와 같습니다.
```

C나 Objective-C의 할당 연산자와 다르게 Swift의 할당 연산자는 그 자체가 값을 반환하지 않습니다. 즉, 다음 구문은 유효하지 않습니다.

```swift
if x = y {
    // x = y는 값을 반환하지 않으므로 이것은 무효합니다.
}
```

이런 특징은 동등 연산자(`==`) 대신 할당 연산자(`=`)를 잘못 사용하는 것을 막아줍니다. Swift에서는 `if x = y`를 무효하게 만듦으로써 이러한 종류의 오류를 피하게 해줍니다.

## 산술 연산자

Swift는 모든 숫자형에 대해 네 가지 표준 **산술 연산자**를 지원합니다.

* 덧셈 (`+`)
* 뺄셈 (`-`)
* 곱셈 (`*`)
* 나눗셈 (`/`)

```swift
1 + 2       // 3과 같습니다.
5 - 3       // 2와 같습니다.
2 * 3       // 6과 같습니다.
10.0 / 2.5  // 4.0과 같습니다.
```

C나 Objective-C의 산술 연산자와 다르게 Swift 산술 연산자는 값이 오버플로우되는 것을 기본적으로 허용하지 않습니다. (`a &+ b` 같은) Swift의 오버플로우 연산자를 사용하면 값의 오버플로우 동작을 설정할 수 있습니다. [오버플로우 연산자](advanced-oprators.md#오버플로우-연산자)를 참고하세요.

덧셈 연산자는 `String` 연결까지 지원합니다. ,

```swift
"hello, " + "world!" // "hello, world"와 같습니다.
```

### 나머지 연산자

**나머지 연산자**(`a % b`)는 `a` 안에 `b` 가 몇 번이나 들어가는지 계산하고 그때 남는 값(**나머지**)을 반환합니다.

> **참고**
>
> 다른 언어에서는 나머지 연산자(`%`)를 **모듈로 연산자**로 부르기도 합니다. 그러나 엄밀히 말해 Swift에서는 음수에 대한 나머지 연산이 모듈로 연산을 의미하므로 모듈로 연산이 아니라 나머지 연산으로 부르는 것이 옳습니다.

아래 그림은 나머지 연산자가 어떻게 작동하는지 나타냅니다. `9 % 4`를 계산할 때는 먼저 `9` 안에 `4`가 얼마나 많이 들어가는지 따지게 됩니다.

![](../../assets/images/reminderInteger.png)

`9` 안에는 `4`를 두 번까지 넣을 수 있고, 그러면 `1`이 남습니다. (사진에서 주황색으로 나타냄)

Swift에서는 이것을 다음과 같이 작성할 수 있습니다.

```swift
9 % 4 // 1과 같습니다
```

`%` 연산자는 `a % b`의 값을 얻기 위해 다음 등식을 계산하고 그 결과로 `remainder`를 반환합니다.

`a` = (`b` x `some multiplier`) + `remainder`

이때 `some multiplier`는 `a` 안에 들어가는 `b`의 개수의 최댓값입니다.

`9`와 `4`를 이 공식에 대입하면 이렇습니다.

`9` = (`4` x `2`) + `1`

`a`가 음수일 때에도 같은 방식으로 계산합니다.

```swift
-9 % 4 // -1과 같습니다
```

`-9`와 `4`를 이 공식에 대입하면 이렇습니다.

`-9` = (`4` x `-2`) + `-1`

즉, 나머지는 `-1`이 됩니다.

`b`가 음수여도 `b`의 부호는 무시됩니다. 즉, `a % b`와 `a % -b`의 값은 항상 같습니다.

### 단항 마이너스 연산자

숫자형의 부호는 **단항 마이너스 연산자**라고 부르는 전위 연산자 `-`를 사용하여 전환할 수 있습니다.

```swift
let three = 3
let minusThree = -three     // minusThree는 -3과 같습니다.
let plusThree = -minusThree // plusThree는 3, 즉 "마이너스 마이너스 삼"과 같습니다.
```

단항 마이너스 연산자(`-`)는 연산을 수행하려는 값 바로 앞에 공백 없이 붙입니다.

### 단항 플러스 연산자

**단항 플러스 연산자**(`+`)는 연산하는 값을 아무런 변화 없이 그대로 반환합니다.

```swift
let minusSix = -6
let alsoMinusSix = +minusSix // alsoMinusSix는 6과 같습니다.
```

단항 플러스 연산자가 실질적으로는 아무것도 하지 않지만, 음수에 단항 마이너스 연산자를 쓸 때 양수에는 플러스 연산자를 사용하여 코드를 대칭적으로 만들 수 있습니다.

## 복합 할당 연산자

C처럼 Swift도 할당 연산자(`=`)와 다른 연산자를 결합한 **복합 할당 연산자**를 지원합니다. 예시로는 **덧셈 할당 연산자**(`+=`)가 있습니다.

```swift
var a = 1
a += 2
// a는 이제 3과 같습니다.
```

표현식 `a += 2`는 `a = a + 2`의 축약형입니다. 사실상 덧셈 연산자와 할당 연산자가 하나의 연산자로 결합하여 동시에 작업을 수행합니다.

> **참고**
>
> 복합 할당 연산자는 값을 반환하지 않습니다. 예를 들어 `b = a += 2`와 같이 쓸 수 없습니다.

Swift 표준 라이브러리에서 지원하는 연산자에 대해서는 [연산자 선언(영문)](https://developer.apple.com/documentation/swift/operator_declarations)에서 자세히 확인할 수 있습니다.

## 비교 연산자

Swift는 아래의 비교 연산자들을 지원합니다.

* 동등, 같다 (`a == b`)
* 부등, 같지 않다 (`a != b`)
* 크다 (`a > b`)
* 작다 (`a < b`)
* 크거나 같다 (`a >= b`)
* 작거나 같다 (`a <= b`)

> **참고**
>
> Swift는 또한 두 가지 **일치 연산자**(`===`와 `!==`)를 지원합니다. 일치 연산자는 두 객체가 동일한 객체 인스턴스를 참조하고 있는지 검사하는 데 사용됩니다. 자세한 정보는 [일치 연산자](classes-and-structures.md#일치-연산자)를 참고하세요.

각각의 비교 연산자는 문장이 참인지 거짓인지를 나타내기 위해 `Bool` 값을 반환합니다.

```swift
1 == 1  // 1은 1과 같으므로 true
2 != 1  // 2는 1과 같지 않으므로 true
2 > 1   // 2는 1보다 크므로 true
1 < 2   // 1은 2보다 작으므로 true
1 >= 1  // 1은 1보다 크거나 같으므로 true
2 <= 1  // 2는 1보다 작거나 같지 않으므로 false
```

비교 연산자는 `if` 구문 등의 조건문에서 주로 사용됩니다.

```swift
let name = "world"
if name == "world" {
    print("hello, world")
} else {
    print("I'm sorry \(name), but I don't recognize you")
}
// name은 "world"와 같으므로 "hello, world" 출력
```

`if` 구문에 대한 자세한 설명은 [제어 흐름](control-flow.md)을 참고하세요.

두 튜플이 같은 개수의 값을 가지고 그 자료형도 서로 같다면, 둘을 비교할 수 있습니다. 튜플에 대해서는 서로 다른 두 값이 나올 때까지 왼쪽에서 오른쪽으로, 한 번에 한 값씩 비교합니다. 그 서로 다른 두 값이 비교되고, 그 비교의 결과가 튜플 비교의 전체 결과를 결정합니다. 모든 원소가 서로 같다면, 튜플 자체도 같게 됩니다. 예를 들면 다음과 같습니다.

```swift
(1, "zebra") < (2, "apple") // 1은 2보다 작으므로 true. "zebra"와 "apple"의 비교는 실행되지 않습니다.
(3, "apple") < (3, "bird")  // 3은 3과 같고, "apple"이 "bird"보다 작으므로 true
(4, "dog") == (4, "dog")    // 4는 4와 같고, "dog"는 "dog"와 같으므로 true
```

위 예시의 첫 번째 줄을 보면 비교가 왼쪽에서 오른쪽으로 이루어짐을 알 수 있습니다. `1`이 `2`보다 작으므로 튜플의 나머지 값들과 관계 없이 `(1, "zebra")`가 `(2, "apple")`보다 작은 것으로 판단합니다. 튜플의 첫 번째 원소에서 이미 비교가 끝났으므로 "zebra"가 "apple"보다 작지 않은 것은 중요하지 않습니다. 그러나 첫 번째 원소가 같다면 두 번쨰 원소가 비교**됩니다.** 두 번째 줄과 세 번째 줄이 그렇습니다.

튜플의 각각의 값들에 대해 연산자를 적용할 수 있을 때에만 해당 연산자로 튜플을 비교할 수 있습니다. 예를 들어, 아래 코드에서 보이듯이 `(String, Int)`형의 튜플은 `String`과 `Int` 모두 `<` 연산자로 비교할 수 있으므로 비교가 가능합니다. 이와 반대로 `Bool` 값에는 `<` 연산자를 적용할 수 없으므로 `(String, Bool)`형의 튜플을 비교하는 것은 불가능합니다.

```swift
("blue", -1) < ("purple", 1)        // 문제 없이 true로 평가됩니다.
("blue", false) < ("purple", true)  // <가 불형을 비교할 수 없으므로 오류입니다.
```

> **참고**
>
> Swift 표준 라이브러리는 원소가 7개보다 작은 튜플에 대해서만 적용 가능한 튜플 비교 연산자를 제공하고 있습니다. 원소가 7개 이상인 튜플을 비교하려면 직접 비교 연산자를 구현해야 합니다.

## 삼항 조건 연산자

**삼항 조건 연산자**는 세 가지 부분으로 이루어져 `question ? answer1: answer2`의 형식을 취하는 특별한 연산자입니다. `question`이 참인지 거짓인지에 따라 두 표현식 중 하나를 평가하기 위한 축약식 표현입니다. `question`이 참이면, `answer1`이 평가되고 그 값을 반환합니다. `question`이 거짓이면 반대로 `answer2`가 평가되고 그 값을 반환합니다.

삼항 조건 연산자는 다음 코드의 축약형입니다.

```swift
if question {
    answer1
} else {
    answer2
}
```

다음 예시에서는 표에서 행의 높이를 구하고 있습니다. 행 높이는, 행에 머리말이 있다면 컨텐츠의 높이보다 50 포인트 높아야 하고, 머리말이 없다면 컨텐츠의 높이보다 20 포인트 높아야 합니다.

```swift
let contentHeight = 40
let hasHeader = true
let rowHeight = contentHeight + (hasHeader ? 50 : 20)
// rowHeight는 90과 같습니다.
```

이 예시는 아래 코드의 축약형이라고 볼 수 있습니다.

```swift
let contentHeight = 40
let hasHeader = true
let rowHeight: Int
if hasHeader {
    rowHeight = contentHeight + 50
} else {
    rowHeight = contentHeight + 20
}
// rowHeight는 90과 같습니다.
```

삼항 조건 연산자를 사용한 첫 번째 예시는 두 번째 예시와 달리 한 줄만으로 `rowHeight`를 설정하여 코드를 더 간결하게 짤 수 있음을 보여줍니다.

삼중 조건 연산자는 두 표현식 중 하나를 고를 때 효율적인 축약형이 되어줍니다. 그렇지만 삼중 조건 연산자를 사용할 때는 항상 주의하세요. 너무 지나치게 사용하다 보면 간결함을 넘어 읽기조차 힘들어질 수 있습니다. 여러 삼항 조건 연산자 인스턴스를 하나의 복합적인 문장에 집어넣지 마세요.

## Nil 병합 연산자

**Nil 병합 연산자**(`a ?? b`)는 옵셔널 `a`가 값을 가지고 있다면 `a`를 개봉하고, `a`가 `nil`이라면 기본 값 `b`를 반환하는 연산자입니다. 표현식 `a`는 반드시 옵셔널형이어야 합니다. 표현식 `b`는 `a` 안에 저장된 값과 자료형이 일치해야만 합니다.

Nil 병합 연산자는 다음 코드의 축약형입니다.

```swift
a != nil ? a! : b
```

위 코드는 삼항 조건 연산자를 사용하고 있습니다. `a`가 `nil`이 아니면 강제 개봉(`a!`)을 사용해 `a` 내부에 밀봉되어 있던 값에 접근하고, `a`가 `nil`이라면 `b`를 반환합니다. 이렇게 조건문을 검사하고 개봉하는 과정을, nil 병합 연산자를 사용하면 더 간결하고 읽기 쉬운 형태로 우아하게 압축할 수 있습니다.

> **참고**
>
> `a`의 값이 `nil`이 아니라면 `b`의 값은 평가되지 않습니다. 이런 것을 **단축 평가**라고 합니다.

아래 예시에서는 nil 병합 연산자를 사용하여 기본 색 이름이나 사용자가 정의하는 옵셔널 색 이름 중 하나를 선택하고 있습니다.

```swift
let defaultColorName = "red"
var userDefinedColorName: String?   // 기본 값은 nil

var colorNameToUse = userDefinedColorName ?? defaultColorName
// userDefinedColorName이 nil이므로 colorNameToUse은 기본 값인 "red"로 설정됩니다.
```

`userDefinedColorName` 변수는 `nil`을 기본 값으로 가지는 옵셔널 `String`로서 정의됩니다. `userDefinedColorName`이 옵셔널형이므로 이 값에 nil 병합 연산자를 사용할 수 있습니다. 위 예시에서는 연산자를 이용하여 `colorNameToUse`라는 `String` 변수의 초기 값을 결정하고 있습니다. `userDefinedColorName`이 `nil`이므로 표현식 `userDefinedCOlorName ?? defaultColorName`은 `defaultColorName`의 값인 `"red"`를 반환합니다.

`nil`이 아닌 값을 `userDefinedColorName`에 할당하고 nil 병합 연산자를 사용하려 하면 `userDefinedColorName` 내부에 밀봉된 값이 기본 값 대신 사용됩니다.

```swift
userDefinedColorName = "green"
colorNameToUse = userDefinedColorName ?? defaultColorName
// userDefinedColorName이 nil이 아니므로 colorNameToUse가 "green"으로 설정됩니다.
```

## 범위 연산자

Swift는 몇 가지 **범위 연산자**를 가지고 있습니다. 이를 이용하여 값의 범위를 간단히 나타낼 수 있습니다.

### 닫힌 범위 연산자

**닫힌 범위 연산자**(`a...b`)는 `a`부터 `b`까지, `a`와 `b`를 포함하는 범위를 정의합니다. `a`의 값은 `b`보다 커서는 안 됩니다.

닫힌 범위 연산자는 `for`-`in` 반복문에서와 같이 모든 값에 대해 범위를 만들어 반복하고자 할 때 유용합니다.

```swift
for index in 1...5 {
    print("\(index) times 5 is \(index * 5)")
}
// 1 times 5 is 5
// 2 times 5 is 10
// 3 times 5 is 15
// 4 times 5 is 20
// 5 times 5 is 25
```

`for-in` 반복문에 대해서는 [제어 흐름](control-flow.md)을 참고하세요.

### 반 연린 범위 연산자

**반 열린 범위 연산자**(`a..<b`)는 `a`부터 `b`까지의 범위를 정의합니다. 이때 `a`는 포함되지만 `b`는 포함되지 않습니다. 첫 번쨰 값은 포함하지만 마지막 값은 포함하지 않으므로 **반 열려** 있다고 표현합니다. 닫힌 범위 연산자에서와 마찬가지로 `a`가 `b`보다 커서는 안 됩니다. `a`와 `b`의 값이 같다면 빈 범위가 만들어질 것입니다.

반 열린 범위는 배열처럼 `0`에서 시작하는 목록을 다룰 때 특히 유용합니다. 마지막 값을 포함하지 않으므로 목록의 길이까지 세어가기에 편리합니다.

```swift
let names = ["Anna", "Alex", "Brian", "Jack"]
let count = names.count
for i in 0..<count {
    print("Person \(i + 1) is called \(names[i])")
}
// Person 1 is called Anna
// Person 2 is called Alex
// Person 3 is called Brian
// Person 4 is called Jack
```

배열은 네 개의 원소를 가지고 있지만 `0..<count`는 반 열린 범위이므로 (배열의 마지막 원소의 인덱스인) `3`까지만 세고 끝납니다. 배열에 대해서는 [배열](collection-types.md#배열)을 참고하세요.

### 단방향 범위

단방향 범위 연산자는 한 방향으로 가능한 만큼 진행되는 범위의 형태 중 하나입니다. 예를 들면, 어떤 배열의 인덱스 `2` 이후의 모든 원소를 포함하는 범위도 해당됩니다. 이런 경우에는 범위 연산자의 한쪽 끝을 생략할 수 있습니다. 이런 범위는 연산자가 한쪽 값만 포함하고 있으므로 **단방향 범위**라고 부릅니다. 예를 들면 이런 형태입니다.

```swift
for name in names[2...] {
    print(name)
}
// Brian
// Jack

for name in names[...2] {
    print(name)
}
// Anna
// Alex
// Brian
```

반 열린 범위 연산자 또한 마지막 범위만 적힌 단방향 범위 형식을 가지고 있습니다. 양쪽에 값을 모두 입력할 때와 마찬가지로 마지막 값은 범위에 포함되지 않습니다. 예를 들면 이렇습니다.

```swift
for name in names[..<2] {
    print(name)
}
// Anna
// Alex
```

단방향 범위는 첨자 뿐만이 아닌 다른 상황에서도 사용될 수 있습니다. 처음 값이 생략된 단방향 범위는 시작 지점이 불명확하므로 반복하는 데 사용할 수 없습니다. 마지막 값을 생략한 단방향 범위는 반복에 사용할 수는 **있습니다.** 그러나 범위가 끝없이 이어지므로 반복문에 명시적인 종료 조건을 꼭 추가하세요. 아래에서 보이듯이 단방향 범위가 특정 값을 포함하는지 여부를 검사할 수도 있습니다.

```swift
let range = ...5
range.contains(7)   // false
range.contains(4)   // true
range.contains(-1)  // true
```

## 논리 연산자

**논리 연산자**는 불 값인 `true`나 `false`를 변경하고 결합합니다. Swift는 C 기반 언어가 가지고 있는 세 가지 표준 논리 연산자를 지원합니다.

* 논리 NOT (`!a`)
* 논리 AND (`a && b`)
* 논리 OR (`a || b`)

### 논리 NOT 연산자

**논리 NOT 연산자**(`!a`)는 불 값을 반전하여 `ture`는 `false`가 되고, `false`는 `true`가 됩니다.

논리 NOT 연산자는 전위 연산자이므로 공백 없이 피연산자 바로 앞에 작성합니다. "`a`가 아니다"라고 읽을 수 있으며, 다음 예시처럼 사용할 수 있습니다.

```swift
let allowedEntry = false
if !alloweEntry {
    print("ACCESS DENINED")
}
// "ACCESS DENINED" 출력
```

`if !allowedEntry`는 "허가된 출입이 아니면"으로 읽을 수 있습니다. 그 다음 줄은 "허가된 출입이 아니면"이 참일 때만, 즉 `allowedEntry`가 `false`일 때만 실행됩니다.

이 예시에서처럼 불 상수나 변수의 이름을 적절히 고르면 코드의 가독성과 간결성이 증가하고 이중 부정이나 헷갈리는 논리 구문을 피할 수 있습니다.

### 논리 AND 연산자

**논리 AND 연산자**(a && b)는 두 값이 모두 `true`인 경우에만 전체 표현식이 `true`가 되는 논리를 표현하는 데 사용됩니다.

둘 중 하나라도 값이 `false`라면, 전체 표현식은 `false`가 됩니다. 사실 **첫 번째** 값이 `false`라면 두 번째 값은 평가되지도 않습니다. 전체 표현식이 `true`가 될 가능성이 없으니 말이지요. 이것은 **단축 평가**라고 부릅니다.

이 예시는 두 `Bool` 값을 평가하여 모두 `true`일 때만 접근을 허용하고 있습니다.

```swift
let enteredDoorCode = true
let passedRetinaScan = false
if enteredDoorCode && passedRetinaScan {
    print("Welcome!")
} else {
    print("ACCESS DENINED")
}
// "ACCESS DENINED" 출력
```

### 논리 OR 연산자

**논리 OR 연산자**(`a || b`)는 두 개의 세로줄을 붙여 만드는 중위 연산자입니다. 이 연산자는 두 값 중 **하나라도** `true`이면 전체 표현식도 `true`가 되는 논리를 표현하는 데 쓰입니다.

논리 AND 연산자처럼 논리 OR 연산자도 표현식을 평가하는 데 단축 평가를 사용합니다. 논리 OR 연산자의 좌변이 `true`라면, 전체 표현식의 결과도 `true`임이 확실하므로 우변은 평가하지 않습니다.

아래 예시에서 첫 번째 `Bool` 값(`hasDoorKey`)는 `false`이지만 두 번째 값(`knowsOverridePassword`)는 `true`입니다. 값 하나가 `true`이므로 전체 표현식 또한 `true`로 평가되어 접근이 허용됩니다.

```swift
let hasDoorKey = false
let knowsOverridePassword = true
if hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// "Welcome!" 출력
```

### 논리 연산자 조합

여러 논리 연산자를 조합하여 더 길고 복합적인 표현식을 만들 수도 있습니다.

```swift
if enteredDoorCode && passedRetinaScan || hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENINED")
}
// "Welcome!" 출력
```

이 예시는 여러 개의 `&&` 연산자와 `||` 연산자를 사용하여 길고 복합적인 표현식을 만들고 있습니다. 그러나 `&&` 연산자와 `||` 연산자는 여전히 두 값에 대해서만 연산합니다. 실질적으로 이 표현식은 세 개의 작은 표현식을 서로 연결해놓은 것에 불과합니다. 이 예시는 다음과 같이 읽을 수 있습니다.

코드를 올바르게 입력하고 홍체 인식을 통과했거나, 맞는 열쇠가 있거나, 보조 비밀번호를 알고 있다면 접근을 하용하여라.

`enteredDoorCode`와 `passedRetinaScan`, `hasDoorKey`의 값들에 의해 처음 두 개의 작은 표현식은 `false`가 됩니다. 그러나 보조 비밀번호를 알고 있으므로 전체 표현식은 `true`로 평가됩니다.

> **참고**
>
> Swift 논리 연산자 `&&`와 `||`는 좌측 결합 방식으로, 가장 왼쪽에 놓인 작은 표현식을 먼저 평가합니다.

### 명시적 괄호

괄호가 꼭 필요하지 않더라도 적는 것이 유용할 때도 있습니다. 괄호는 복잡한 표현식의 의도를 명확하게 보여주고 읽기도 쉽게 해줍니다. 위의 예시에서는 복합적인 표현식의 첫 부분을 괄호로 감싸는 것이 의도를 명확하게 하는 데 도움을 줍니다.

```swift
if (enteredDoorCode && passedRetinaScan) || hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENINED")
}
// "Welcome!" 출력
```

괄호를 적으면 처음 두 값이 하나로 묶여 전체 논리의 가능한 세 가지 경우 중 하나임을 명확히 보여줍니다. 전체 표현식의 결과는 그대로지만 전체적인 의도가 더 분명해집니다. 언제나 간결함보다 가독성이 더 중요합니다. 의도를 명확히 할 수 있다면 괄호를 삽입하세요.

