---
layout: default
title: 클로저
description: Closures
parent: Swift 안내서
nav_order: 7
---

# 클로저

{: .no_toc }

<details markdown="block">
  <summary>
    목차
  </summary>
  {: .text-delta }
1. TOC
{:toc}
</details>

---

**클로저**는 독립적으로 기능성을 가져 코드 내에서 전달하고 사용하는 단위입니다. Swift의 클로저는 C나 Objective-C의 블록, 다른 프로그래밍 언어의 람다와 비슷합니다.

클로저는 자신이 정의된 주위에서 상수나 변수를 포획해 이에 대한 참조를 저장할 수 있습니다. 이것을 상수나 변수 **둘러싸기**라고 합니다. Swift는 포획의 메모리 관리를 전부 대신해줍니다.

> **참고**
> 
> 포획이라는 개념에 익숙하지 않아도 괜찮습니다. 아래 [값 포획](#값-포획)에서 자세히 설명합니다.

[함수](functions.md)에서 소개된 전역 함수나 중첩 함수 모두 사실은 클로저의 특수한 예시입니다. 클로저는 다음 세 가지 형식 중 하나를 취합니다:

* 전역 함수는 이름이 있고 어느 값도 포획하지 않는 클로저입니다.
* 중첩 함수는 이름이 있고 둘러싸는 함수로부터 값을 포획할 수 있는 클로저입니다.
* 클로저 표현식은 이름이 없고 주위로부터 값을 포획할 수 있는 가벼운 문법의 클로저입니다.

Swift의 클로저 표현식은 깔끔하고 명확한 스타일을 지녔으며, 최적화를 통해 일반적인 상황에서 간결하고 모호함이 없는 문법을 유지합니다. 이 최적화는 다음을 말합니다:

* 문맥에 따른 매개 변수형 및 반환형 추론
* 단일 표현식 클로저의 묵시적 반환
* 전달 인자 이름의 축약
* 후행 클로저 문법

## 클로저 표현식

[중첩 함수](functions.md#중첩-함수)에 소개된 중첩 함수는 큰 함수 내부에서 독립적인 코드 단위에 이름을 붙이고 정의하는 편리한 방법입니다. 그러나 가끔은 함수와 유사한 구조를 완전한 정의와 이름 없이 짧게 작성하는 것이 필요하기도 합니다. 특히 함수나 메서드가 전달 인자로 하나 이상의 함수를 받을 때 더 그렇습니다.

**클로저 표현식**은 간결하고 집중적인 문법으로 인라인 클로저를 작성하는 방법입니다. 클로저 표현식은 명확성이나 의도를 유지한 채 짧은 형식으로 클로저를 작성하기 위해 몇 가지 문법 최적화를 제공합니다. 아래 클로저 표현식 예시를 통해 `sorted(by:)` 메서드 하나에 최적화를 하나씩 적용해가면서, 동일한 기능을 더 간결하게 표현해봅니다.

### 정렬 메서드

Swift의 표준 라이브러리는 `sorted(by:)`라는 메서드를 제공합니다. `sorted(by:)` 메서드는 전달받은 정렬 클로저의 결과에 따라 알려진 자료형의 값 배열을 정렬합니다. 정렬이 끝나고 나면 원소들을 기존과 동일한 자료형과 크기의 새로운 배열에 정렬된 순서로 담아 반환합니다. 기존 배열은 `sorted(by:)` 메서드로 수정되지 않습니다.


아래 클로저 표현식 예시는 `String` 값들의 배열을 `sorted(by:)` 메서드를 이용하여 알파벳 역순으로 정렬합니다. 정렬할 배열의 초기 상태는 이렇습니다:

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
```

`sorted(by:)` 메서드는 한 클로저를 받습니다. 이 클로저는 배열의 원소와 같은 자료형의 인자 두 개를 받아, 두 값 중 무엇이 앞에 와야 하는지 `Bool` 값을 반환하여 알려줍니다. 정렬 클로저는 첫 번째 값이 두 번째 값보다 **앞에** 있어야 하면 `true`를, 그렇지 않으면 `false`를 반환하도록 되어 있습니다.

이 예시는 `String` 값들의 배열을 정렬하므로 정렬 클로저는 `(String, String) -> Bool`형의 함수여야 합니다.

정렬 클로저를 제공하는 방법으로 첫 번째는 해당 자료형의 일반 함수를 작성하여 `sorted(by:)` 메서드에 인자로 전달하는 것입니다.

```swift
func backward(_ s1: String, _ s2: String) -> Bool {
    return s1 > s2
}
var reveredNames = names.sorted(by: backward)
// reversedNames는 ["Ewa", "Daniella", "Chris", "Barry", "Alex"]와 같습니다.
```

첫 번째 문자열(`s1`)이 두 번째 문자열(`s2`)보다 크면 `backward(_:_:)` 함수는 `true`를 반환하여 정렬된 배열에서 `s1`이 `s2`보다 먼저 나타나야 한다고 알려줍니다. 문자열의 문자에 대해 "크다"는 것은 "알파벳순에서 뒤에 온다"는 것을 말합니다. 즉, 문자 `"B"`는 문자 `"A"`보다 "크고, 문자열 `"Tom"`은 문자열 `"Tim"`보다 큽니다. 이로써 `"Barry"`가 `"Alex"` 앞에 오는 식으로 알파벳 역순이 만들어집니다.

그러나 아직까지는 핵심적인 단일 표현식 함수(`a > b`)를 너무 길게 적고 있습니다. 이 예시에서는 클로저 표현식 문법을 사용해 정렬 클로저를 인라인으로 적는 것이 낫습니다.

### 클로저 표현식 문법

클로저 표현식 문법은 다음과 같은 일반 형식을 가집니다:

```swift
{ ((parameters)) -> (return type) in
    (statements)
}
```

클로저 표현식 문법에서 **매개 변수**는 인-아웃 매개 변수도 가능하지만, 기본 값을 가질 수는 없습니다. 가변 매개 변수는 이름을 붙여준다면 사용할 수 있습니다. 매개 변수형이나 반환형에 튜플도 사용할 수 있습니다.

아래 예시는 위의 `backward(_:_:)` 함수의 클로저 표현식 버전입니다.

```swift
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
    return s1 > s2
})
```

매개 변수와 반환 형의 선언이 `backward(_:_:)` 함수에서와 같습니다. 두 경우 모두 `(s1: String, s2: String) -> Bool`로 적습니다. 그러나 인라인 클로저 표현식에서 매개 변수와 반환형은 중괄호 밖이 아닌 **안에** 적게 됩니다.

클로저 몸체는 `in` 키워드로 시작합니다. 이 키워드는 클로저의 매개 변수와 반환형의 정의가 끝났고 몸체가 시작함을 나타냅니다.

클로저의 몸채가 매우 짧으므로 한 줄에 적어도 됩니다.

```swift
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )
```

`sorted(by:)` 메서드를 호출하는 전체적인 상황은 같습니다. 괄호 쌍이 여전히 메서드의 전체 인자를 감싸고 있습니다. 그러나 인자가 이제는 인라인 클로저입니다.

### 문맥에 따른 자료형 추론

정렬 클로저가 메서드의 인자로서 전달되므로, Swift는 클로저의 매개 변수형과 반환형을 추론할 수 있습니다. `sorted(by:)` 메서드는 문자열 배열에 대해 호출되므로 인자는 반드시 `(String, String) -> Bool`형의 함수여야 합니다. `(String, String)`과 `Bool`형을 클로저 표현식의 정의에 명시할 필요가 없다는 의미입니다. 모든 자료형이 추론 가능하므로 반환 화살표(`->`)와 매개 변수 이름을 감싸는 괄호까지 생략할 수 있습니다.

```swift
reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )
```

함수나 메서드에 인라인 클로저 표현식을 전달할 때라면 언제든 매개 변수형과 반환형을 추론할 수 있습니다. 함수나 메서드의 인자로 인라인 클로저를 전달할 때 굳이 완전한 형식을 갖출 필요가 없지요.

그렇지만 원한다면 물론 자료형을 명시할 수 있고, 코드의 모호함을 없애준다면 그렇게 하는 편이 더 낫습니다. `sorted(by:)` 메서드의 경우에는 정렬이 진행된다는 점에서 클로저의 목적이 명확하고, 문자열 배열을 정렬하고 있기에 클로저가 `String` 값을 다룰 것임을 안전하게 가정할 수 있습니다.

### 단일 표현식 클로저의 묵시적 반환

단일 표현식 클로저는 다음 버전에서 보이듯이 선언에서 `return` 키워드를 생략해도 그 유일한 표현식의 결과를 묵시적으로 반환합니다.

```swift
reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )
```

`sorted(by:)` 메서드의 인자의 함수형에 따라 클로저는 분명히 `Bool` 값을 반환해야 합니다. 클로저의 몸체는 `Bool` 값을 반환하는 단일 표현식(`s1 > s2`)이므로 모호함이 없어 `return` 키워드를 생략할 수 있습니다.

### 전달 인자 이름의 축약

Swift는 기본적으로 인라인 클로저의 인자 이름에 대한 축약형을 제공합니다. 클로저의 인자 값을 `$0`, `$1`, `$2`와 같은 식의 이름으로 참조할 수 있습니다.

클로저 표현식에 이 축약형 인자 이름을 사용하면 정의에서 인자 목록을 생략할 수도 있습니다. 축약된 인자들의 자료형은 예상되는 함수형으로부터 추론되며, 사용된 축약형 이름 중 가장 높은 번호가 클로저가 받는 인자의 수를 결정합니다. 클로저 몸체 자체가 클로저 표현식을 이루므로, `in` 키워드 또한 생략 가능합니다.

```swift
reversedNames = names.sorted(by: { $0 > $1 } )
```

여기서 `$0`과 `$1`은 각각 클로저의 첫 번째, 두 번째 `String` 인자를 참조합니다. `$1`이 가장 번호가 높은 축약형 인자이므로 클로저는 두 개의 인자를 받기로 판단합니다. `sorted(by:)` 함수가 두 문자열을 인자로 하는 클로저를 받으므로, `$0`과 `$1` 모두 `String` 형입니다.

### 연산자 메서드

사실 위 클로저 표현식을 **더 짧게** 줄일 수 있습니다. Swift의 `String`형은 크다 연산자(`>`)에 대한 자신만의 구현을 따로 정하고 있습니다. 문자열에서 크다 연산자는 메서드로, 두 `String`형 매개 변수를 받아 `Bool`형 값을 반환합니다. 이것은 `sorted(by:)` 메서드에 필요한 메서드형과 정확히 일치합니다. 따라서 단순히 크다 연산자를 전달하면 Swift가 이를 문자열 전용 구현으로 사용하려 함을 추론합니다.

```swift
reversedNames = names.sorted(by: >)
```

연산자 메서드에 관해서는 [연산자 메서드](advanced-operators.md#연산자-메서드)를 참고하세요.

## 후행 클로저

함수의 마지막 인자로 클로저 표현식을 전달하려 하는데 그 표현식이 길다면, **후행 클로저**를 사용하세요. 함수 호출의 괄호 다음에 후행 클로저를 작성해도 클로저는 여전히 함수의 인자로 전달됩니다. 후행 클로저 문법을 사용하여 함수를 호출할 때에는 첫 클로저에 대한 인자 레이블을 적지 않습니다. 함수는 여러 후행 클로저를 포함할 수 있습니다. 다만 처음 몇 예시에서는 하나의 후행 클로저만을 사용합니다.

```swift
func someFunctionThatTakesAClosure(closure: () -> Void) {
    // 함수 몸체
}

// 후행 클로저 없이 이 함수를 호출하면

someFunctionThatTakesAClosure(closure: {
    // 클로저 몸체
})

// 후행 클로저를 사용하여 이 함수를 호출하면

someFunctionThatTakesAClosure() {
    // 후행 클로저 몸체
}
```

위의 [클로저 표현식 문법](#클로저-표현식-문법)에서 보인 문자열 정렬 클로저는 후행 클로저로서 `sorted(by:)` 메서드의 괄호 밖에 적을 수도 있습니다.

```swift
reversedNames = names.sorted() { $0 > $1 }
```

클로저 표현식이 함수나 메서드의 유일한 인자라면, 후행 클로저를 사용하고 호출 시 함수나 메서드 이름 다음에 오는 괄호 쌍 `()`을 생략할 수 있습니다.

```swift
reversedNames = names.sorted { $0 > $1 }
```

후행 클로저는 클로저가 너무 길어 한 줄에 인라인으로 적을 수 없을 때 가장 유용합니다 .예를 들어, Swift의 `Array`형은 클로저 표현식 하나만을 인자로 받는 `map(_:)` 메서드를 가지고 있습니다. 그 클로저는 배열의 각 원소에 대해 매번 호출되어 그 원소에 대응되는 다른 값(다른 자료형도 가능)을 반환합니다. 이 대응 관계의 특성과 반환형을 클로저로 작성하여 `map(_:)`에 전달하면 됩니다.

`map(_:)` 메서드는 전달받은 클로저를 각 원소에 적용하여 얻은 값들로 이루어진 새로운 배열을 그 순서를 보존하여 반환합니다.

다음 예시에서는 `map(_:)`와 후행 클로저를 함께 사용해 `Int` 값 배열을 `String` 값 배열로 바꾸고 있습니다. 배열 `[16, 58, 510]`으로부터 새로운 배열 `["OneSix", "FiveEight", "FiveOneZero"]`를 만듭니다.

```swift
let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
```

위 코드는 한 자리 자연수와 영어 이름 간의 대응 관계를 나타내는 딕셔너리를 생성합니다. 문자열로 바꿀 정수 배열도 정의합니다.

이제 배열의 `map(_:)` 메서드로 후행 클로저 표현식을 전달하여 `numbers` 배열로부터 `String` 값 배열을 만들 수 있습니다.

```swift
let strings = numbers.map { (number) -> String in
    var number = number
    var output = ""
    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0
    return output
}
// strings는 [String]형으로 추론되며 그 값은
// ["OneSix", "FiveEight", "FiveOneZero"]입니다.
```

`map(_:)` 메서드는 배열의 각 원소에 대해 매번 클로저 표현식을 호출합니다. 클로저의 입력 매개 변수 `number`에 자료형을 명시할 필요는 없습니다. 대응되는 배열의 값들로부터 자료형을 추론할 수 있습니다.

이 예시에서 변수 `number`는 클로저의 `number` 매개 변수 값으로 초기화되어 클로저 몸체에서 수정됩니다. 함수와 클로저의 매개 변수는 항상 상수입니다. 클로저 표현식은 또한 반환형을 `String`으로 지정하여 대응되는 출력 배열에 저장될 자료형을 정합니다.

클로저 표현식은 호출될 때마다 `output`이라는 문자열을 만듭니다. 나머지 연산자로 `number`의 마지막 자리를 계산하고(`number % 10`) 이 숫자를 이용하여 `digitNames` 딕셔너리에서 적당한 문자열을 찾습니다. 클로저는 `0`보다 모든 정수에 대한 문자열 표현을 만드는 데 사용될 수 있습니다.

> **참고**
> 
> `digitNames` 딕셔너리의 첨자 다음에는 느낌표(`!`)가 따라옵니다. 키가 존재하지 않을 수도 있으므로 딕셔너리 첨자가 옵셔널 값을 반환하는 것입니다. 위 예시에서는 `number % 10`이 항상 `digitNames` 딕셔너리의 유효한 첨자 키임이 보장됩니다. 따라서 느낌표를 사용하여 첨자의 옵셔널 반환 값에 저장된 `String` 값을 강제 개봉합니다.

`digitNames` 딕셔너리에서 얻은 문자열은 `output` **앞에** 추가되어 수의 문자열 표현을 거꾸로 만들어갑니다. (`number % 10`은 `16`에 대해 `6`을, `58`에 대해 `8`을, `510`에 대해 `0`을 반환합니다.)

그 다음 `number` 변수는 `10`으로 나누어집니다. 값이 정수이므로 결과는 내림되어 `16`은 `1`이, `58`은 `5`가, `510`은 `51`이 됩니다.

`number`가 `0`이 될 때까지 이 과정이 반복됩니다. 클로저가 `output` 문자열을 반환하면 이를 `map(_:)` 메서드가 출력 배열에 추가합니다.

위에서 사용한 후행 클로저 문법은 `map(_:)` 메서드의 바깥 괄호로 전체 클로저를 감싸지 않고도 클로저 기능을 깔끔하게 캡슐화합니다.

함수가 클로저를 여러 개 받는다면, 첫 번째 후행 클로저에 대한 인자 레이블은 생략하고 나머지 후행 클로저들에 레이블을 붙이세요. 예를 들어, 앨범에서 사진을 불러오는 함수를 봅시다.

```swift
func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {
    if let picture = download("photo.jpg", from: server) {
        completion(picture)
    } else {
        onFailure()
    }
}
```

사진을 불러오기 위해 이 함수를 호출할 때는 클로저를 두 개 제공해야 합니다. 첫 번째 클로저는 다운로드가 성공했을 때 사진을 띄우는 완료 처리자입니다. 두 번째 클로저는 사용자에게 오류를 띄우는 오류 처리자입니다.

```swift
loadPicture(from: someServer) { picture in
    someView.currentPicture = picture
} onFailure: {
    print("Couldn't download the next picture.")
}
```

여기서 `loadPicture(from:completion:onFailure:)` 함수는 네트워크 작업을 백그라운드로 보내 작업이 끝났을 때 두 완료 처리자 중 하나를 호출합니다. 함수를 이렇게 작성하면, 네트워크 실패를 처리하는 코드와 다운로드 성공 후 UI를 업데이트하는 코드를 한 클로저에 담지 않고 깔끔하게 분리할 수 있습니다.

## 갑 포획














wip...!