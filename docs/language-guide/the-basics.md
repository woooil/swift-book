---
layout: default
title: The Basics
nav_order: 1
parent: Language Guide
---

# 기본

Swift는 iOS, macOS, watchOS, tvOS 앱 개발을 위해 새롭게 만들어진 프로그래밍 언어입니다. 그럼에도 Swift의 많은 부분은 C와 Objective-C에서의 경험과 크게 다르지 않을 것입니다.

Swift는 C와 Objective-C의 모든 기초 자료형에 대응되는 Swift만의 버전을 가지고 있습니다. 정수형에는 `Int`, 부동 소수점 값에는 `Double`과 `Float`, 불 값에는 `Bool`, 문자 데이터에는 `String`을 사용하면 됩니다. 여기에 더해 Swift는 [컬렉션형](collection-types.md)에 소개되어 있듯이 세 가지 주요 컬렉션형을 강력한 버전으로 만들어 `Array`, `Set`, `Dictionary`까지 제공합니다.

C에서와 마찬가지로 Swift는 값에 고유한 이름을 붙여 변수로서 저장하고 참조합니다. 게다가 Swift는 값이 고정된 변수의 활용성을 극대화합니다. 이런 변수를 상수라고 부르며, C에서의 상수보다도 훨씬 강력합니다. 프로그램을 작성하다 보면 변하지 않아야 하는 값들을 다뤄야 할 때가 많습니다. 이런 경우에 상수가 사용되면서 Swift의 코드는 더 안전하고 그 의도가 명확해집니다.

익숙한 자료형 말고도 Swift에는 튜플처럼 Objective-C에서는 볼 수 없었던 고급 자료형이 존재합니다. 튜플을 사용하면 여러 값들을 그룹으로 묶어 생성하고 전달할 수 있습니다. 함수에서 여러 값을 한 번에 반환하기 위해 이들을 하나의 혼합된 값으로 묶는 데 튜플을 사용할 수 있습니다.

Swift는 또한 값이 없음을 표현하기 위해 옵셔널형을 사용합니다. 옵셔널은 "값이 **존재하고** 그 값은 x와 같다"라고 알려주거나, 아니면 아예 "값이 **존재하지 않는다**"라고 알려줍니다. 옵셔널은 Objective-C의 포인터에서의 `nil`과 비슷하지만 클래스 뿐만 아니라 모든 자료형에서 사용할 수 있다는 차이가 있습니다. 옵셔널은 Objective-C에서의 `nil` 포인터보다 더 안전하고 표현적이기도 하지만, Swift의 강력한 기능들의 핵심이 되기도 합니다.

Swift는 **자료형 안전** 언어로서, 작성된 코드가 다룰 수 있는 값들의 자료형을 명확히 알려줍니다. 코드 일부에 `String`이 사용된다면, 자료형 안전성이 `Int`를 실수로라도 전달하는 일을 막아줍니다. 마찬가지로 자료형 안정성은 옵셔널이 아닌 일반 `String`이 필요한 코드에 옵셔널 `String`을 실수로 넘기는 일도 막아줍니다. 자료형 안정성은 개발 단계에서 가능한 빨리 오류를 찾고 수정할 수 있도록 도와줍니다.

## 상수와 변수

상수와 변수는 특정 자료형의 값\(예를 들어 정수 `10`이나 문자열 `"Hello"`\)을 이름\(예를 들어 `maximumNumberOfLoginAttempts`나 `welcomeMessage`\)과 연결시켜줍니다. **상수**의 값은 한 번 설정되고 나면 더 이상 바뀔 수 없습니다. 이와 반대로 **변수**는 추후에도 다른 값으로 바뀔 수 있습니다.

### 싱수와 변수 선언

상수와 변수는 항상 사용되기 전에 먼저 선언되어야 합니다. 상수는 `let` 키워드로, 변수는 `var` 키워드로 선언하면 됩니다. 예시로 사용자가 로그인을 시도한 횟수를 추적하는 상황에서 변수와 상수가 어떻게 쓰이는지 나타나 있습니다.

```swift
let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0
```

이 코드는 다음과 같이 읽을 수 있습니다.

"`maximumNumberOfLoginAttempts`라는 이름의 상수를 하나 선언하고 그 값을 `10`으로 하여라. 그리고 나서 `currentLoginAttemp`라는 이름의 새로운 변수를 선언하고 초기 값은 `0`으로 하여라."

이 예시에서는 허용되는 최대 로그인 시도 횟수는 변할 일이 없으므로 이 값을 상수로 선언했습니다. 현재 로그인 시도 횟수는 로그인 시도가 실패할 떄마다 증가해야 하므로 변수로 선언했습니다.

두 개 이상의 상수나 변수를 쉼표로 구분하여 한 줄에서 모두 선언할 수도 있습니다.

```swift
var x = 0.0, y = 0.0, z = 0.0
```

> **참고**
>
> 코드 내에서 저장된 값이 변하지 않는 값이라면 언제나 `let` 키워드를 사용하여 상수로 선언하세요. 변수는 오직 변할 필요가 있는 값을 저장할 때만 사용하세요.

### 자료형 명시

상수나 변수를 선언할 때, 저장될 수 있는 값의 유형을 보다 분명하게 나타내기 위해 **자료형을 명시**할 수 있습니다. 상수나 변수 이름 뒤에 콜론을 붙이고 한 칸을 띄운 뒤 사용하려는 자료형의 이름을 적으세요.

다음 예시에는 변수 `welcomeMessage`가 `String` 값을 저장할 수 있다고 알려주는 자료형 명시가 나와 있습니다.

```swift
var welcomeMessage: String
```

선언에 포함된 콜론은 "... 자료형의 ..."라는 뜻이므로 위 코드는 다음과 같이 읽을 수 있습니다.

"이름이 `welcomeMessage`인 `String` 자료형의 변수를 선언하여라."

"`String` 자료형의"이라는 말은 "아무 `String` 값이나 저장할 수 있다"라는 것을 의미합니다. "저장할 수 있는 값의 자료형"\(또는 "저장할 수 있는 것의 유형"\)이라고 생각하세요.

이제 `welcomeMessage` 변수는 어떤 문자열이든 오류 없이 저장할 수 있습니다.

```swift
welcomeMessage = "Hello"
```

자료형이 같고 서로 관련 있는 둘 이상의 변수는 쉼표로 구분하고 마지막 변수 이름 뒤에서 자료형을 한 번만 명시함으로써 모두 한 줄에 정의할 수 있습니다.

```swift
var red, green, blue: Double
```

> **참고**
>
> 실제로는 자료형을 명시하는 상황이 매우 드뭅니다. 상수나 변수를 정의하는 시점에 초기 값을 함께 설정한다면, Swift는 [자료형 안전성과 자료형 추론](the-basics.md#undefined-5)에 소개된 것처럼 거의 대부분 그 상수나 변수에 쓰이는 자료형을 추론할 수 있습니다. 상술한 `welcomeMessage` 예시에서는 초기 값이 주어져 있지 않으므로 자료형을 추론하지 못해 자료형 명시로 `welcomeMessage` 변수의 자료형을 지정해준 것입니다.

### 상수와 변수 명명

상수와 변수의 이름은 유니코드 문자를 포함한 거의 모든 문자로 만들 수 있습니다.

```swift
let π = 3.14159
let 你好 = "你好世界"
let 🐶🐮 = "dogcow"
```

다만 상수와 변수 이름에 공백 문자나 수학 기호, 화살표, 개인 사용 영역의 유니코드 스칼라 값, 선 문자, 상자 문자는 쓰일 수 없습니다. 이름 중간이나 끝에 숫자가 포함되는 건 상관 없지만 처음부터 숫자로 시작해서는 안 됩니다.

> **참고**
>
> 예약된 Swift 키워드와 같은 이름을 상수나 변수에 붙이고 싶다면, 그 이름을 백틱\(````` \)으로 감싸 사용하세요. 그렇지만 정말 다른 방법이 없는 경우가 아니라면 키워드를 이름으로 사용하지는 마세요.

이미 존재하는 변수의 값은 자료형이 일치하는 다른 값으로 바꿀 수 있습니다. 아래 예시에서 `friendlyWelcome`의 값은 `"Hello"`에서 `"안녕하세요!"`로 바뀝니다.

```swift
var friendlyWelcome = "Hello!"
friendlyWelcome = "안녕하세요!"
// 이제 friendlyWelcome은 "안녕하세요!"이 되었습니다.
```

변수와 다르게 상수의 값은 설정되고 나면 더 이상 바뀔 수 없습니다. 바꾸려고 시도하면 컴파일 시에 오류가 발생할 것입니다.

```swift
let languageName = "Swift"
languageName = "Swift++"
// 컴파일 시간 오류입니다. languageName은 변경될 수 없습니다.
```

### 상수와 변수 출력

상수와 변수의 출력은 `print(_:separator:terminator:)` 함수로 할 수 있습니다.

```swift
print(friendlyWelcome)
// "안녕하세요!" 출력
```

`print(_:separator:terminator:)` 함수는 하나 이상의 값을 적당한 대상으로 출력해내는 전역 함수입니다. 예를 들어 Xcode에서는 `print(_:separator:terminator:)` 함수가 Xcode의 "콘솔" 창으로 결과를 출력합니다. `seperator`와 `terminator` 매개 변수에는 기본 값이 정해져 있으므로 함수를 호출할 때 생략해도 됩니다. 기본적으로 함수는 내용을 출력한 뒤 개행을 하면서 종료됩니다. 개행 없이 출력하려면 `terminator`로 비어 있는 문자열을 넘기세요. `print(someValue, terminator: "")`와 같은 식입니다. 매개 변수의 기본 값에 대한 정보는 [매개 변수 기본 값](the-basics.md)을 확인하세요.

Swift는 **문자열 삽입**을 사용합니다. 긴 문자열 내에 상수나 변수의 이름을 삽입하고 Swift에게 그 부분을 해당하는 상수나 변수의 값으로 바꾸도록 지시합니다. 이름을 괄호로 감싸고 여는 괄호 앞에 백슬래시를 붙이세요.

```swift
print("The current value of friendlyWelcome is \(friendlyWelcome)")
// "The current value of friendlyWelcome is 안녕하세요!" 출력
```

> **참고**
>
> 문자열 삽입에서 사용할 수 있는 모든 옵션은 [문자열 삽입](the-basics.md)에 소개되어 있습니다.

## 주석

스스로 확인하기 위한 메모나 리마인더 등의 글을 코드에 포함하려면 주석을 사용해보세요. Swift 컴파일러가 코드를 컴파일할 때 주석은 무시합니다.

Swift의 주석은 C의 주석과 매우 유사합니다. 한 줄로 이루어진 단행 주석은 슬래시 두 개\(`//`\)로 시작합니다.

```swift
// 이것은 주석입니다.
```

다행 주석은 별표 앞에 슬래시 하나를 붙인 기호\(`/*`\)로 시작하여 별표 뒤에 슬래시를 붙인 기호\(`*/`\)로 끝납니다.

```swift
/* 이것 역시 주석입니다.
하지만 여러 줄짜리이지요. */
```

C에서의 다행 주석과 다르게 Swift에서의 다행 주석은 다른 다행 주석과 중첩될 수 있습니다. 바깥쪽 다행 주석을 시작하고 그 주석 안에서 두 번째 다행 주석을 시작하세요. 두 번째 주석을 끝낸 뒤 첫 번째 주석을 끝내세요.

```swift
/* 이것은 첫 번째 다행 주석의 시작입니다.
 /* 이것은 두 번째, 내부 다행 주석입니다. */
이것은 첫 번째 다행 주석의 끝입니다. */
```

중첩 다행 주석을 사용하면 복잡한 코드에 이미 다행 주석이 포함되어 있더라도 그 코드를 빠르고 쉽게 주석 처리할 수 있습니다.

## 세미콜론

다른 언어들과 다르게, Swift에서는 각 문장이 끝난 뒤에 세미콜론\(`;`\)을 덧붙일 필요가 없습니다. 물론 원한다면 세미콜론을 붙여도 됩니다. 다만 한 줄에 여러 문장을 동시에 작성하려면 세미콜론을 **반드시** 붙여야 합니다.

```swift
let cat = "🐱"; print(cat)
// "🐱" 출력
```

## 정수

**정수**는 `42`나 `-23`처럼 소수 부분이 없는 수를 말합니다. 정수는 부호가 **있을** 수도\(양수, `0`, 음수\), **없을** 수도\(양수, `0`\) 있습니다.

Swift는 8, 16, 32, 64비트 형태의 부호 있는 정수와 부호 없는 정수를 지원합니다. 이런 정수들은 C와 비슷한 명명 관례를 따릅니다. 부호 없는 8비트 정수는 `UInt8`의 자료형으로, 부호 있는 32비트 정수는 `Int32`로 나타냅니다. Swift의 다른 모든 자료형과 마찬가지로 이런 정수형의 이름들은 대문자로 시작합니다.

### 정수의 범위

각각의 정수형이 가지는 최솟값과 최댓값에는 `min`과 `max` 프로퍼티를 사용하여 접근할 수 있습니다.

```swift
let minValue = UInt8.min  // minValue은 0과 같으며 그 자료형은 UInt8입니다.
let maxValue = UInt8.max  // maxValue은 255와 같으며 그 자료형은 UInt8입니다.
```

이런 프로퍼티의 값은 해당 정수형과 자료형이 동일하므로\(위의 경우 `UInt8`\) 자료형이 같은 다른 값들과 함께 표현식에 쓰일 수 있습니다.

### Int

대부분의 경우, 코드를 작성할 때 정수의 크기를 특정할 필요는 없습니다. Swift는 `Int`라고 하는 추가적인 정수형을 제공합니다. `Int`는 현재 플랫폼의 기본 단어 크기와 같은 크기를 가집니다.

* 32비트 플랫폼에서 `Int`는 `Int32`와 크기가 같습니다.
* 64비트 플랫폼에서 `Int`는 `Int64`와 크기가 같습니다.

특정한 크기의 정수를 다뤄야 하는 것이 아니라면 항상 정수 값에 `Int`를 사용하세요. 그래야 코드가 일관적이게 되고 서로 간의 연산이 가능해집니다. 32비트 플랫폼에서도 `Int`는 `-2,147,483,648`과 `2,147,483,647` 사이의 모든 값을 저장할 수 있습니다. 웬만한 정수를 저장하기에 충분히 크지요.

### UInt

Swift는 부호가 없는 정수형인 `UInt`까지 지원하며, 이 역시 현재 플랫폼의 기본 단어 크기와 같은 크기를 가집니다.

* 32비트 플랫폼에서 `UInt`는 `UInt32`와 크기가 같습니다.
* 64비트 플랫폼에서 `UInt`는 `UInt64`와 크기가 같습니다.

> **참고**
>
> `UInt`는 플랫폼의 기본 단어 크기와 같은 크기의 부호 없는 정수가 특별히 필요한 경우에만 사용하세요. 그런 경우가 아니라면, 저장될 값이 음수가 아니더라도 `Int`를 선호하기 바랍니다. 정수 값들에 대해 `Int`를 일관적으로 사용하여 서로 간의 연산을 자유롭게 하고, 다른 숫자형과의 불필요한 변환을 없애고, 정수형 추론을 일치시키세요. 자세한 정보는 [자료형 안전성과 자료형 추론](the-basics.md#undefined-5)에 있습니다.

## 부동 소수점 수

**부동 소수점 수**는 `3.14159`, `0.1`, `-273.15`와 같이 소수 부분을 가진 수를 말합니다.

부동 소수점 자료형은 정수형보다 더 넓은 값의 범위를 표현하고, `Int`에 저장될 수 있는 수보다 더 크고 작은 수까지 저장할 수 있습니다. Swift는 두 가지 부호 있는 부동 소수점 자료형을 지원합니다.

* `Double`은 64비트 부동 소수점 수를 나타냅니다.
* `Float`은 32비트 부동 소수점 수를 나타냅니다.

> **참고**
>
> `Double`은 최소 15자리의 정밀성을 가지는 반면 `Float`의 정밀성은 최소 6자리입니다. 적절한 부동 소수점 자료형이 무엇인지는 여러분이 다루려는 값의 성질과 범위에 따라 결정됩니다. 두 자료형 모두 적절하다면 `Double`을 선호하세요.

## 자료형 안전성과 자료형 추론

Swift는 **자료형 안전** 언어입니다. 자료형 안전 언어는 작성된 코드가 다룰 수 있는 값들의 자료형을 명확히 알려줍니다. 어떤 코드가 `String`을 필요로 한다면, `Int`는 실수로라도 전달될 수 없습니다.

Swift는 자료형 안전 언어로서, 컴파일 시 **자료형 검사**를 수행하고 잘못된 자료형을 오류로 걸러냅니다. 이를 통해 개발 과정에서 가능한 빨리 오류를 파악하고 수정할 수 있게 됩니다.

자료형 검사는 다양한 자료형의 값들을 다룰 때 오류가 발생하지 않도록 도와줍니다. 그러나 이것이 상수나 변수를 선언할 때마다 자료형을 특정해야 한다는 뜻은 아닙니다. 필요한 자료형을 특정하지 않았다면, Swift는 **자료형 추론**을 통해 적절한 자료형을 찾아냅니다. 컴파일러는 코드를 컴파일하면서 주어진 값들을 확인하여 특정 표현식의 자료형을 알아서 추론합니다.

자료형 추론 덕분에 Swift에서는 C나 Objective-C에서보다 자료형 선언이 훨씬 덜 필요합니다. 상수나 변수는 여전히 명시적으로 작성해야 하지만, 이들의 자료형을 특정하는 수고는 덜 수 있습니다.

자료형 추론은 특히나 상수나 변수를 선언하면서 초기 값을 지정할 때 유용합니다. 보통은 상수나 변수를 선언하는 시점에 **리터럴 값**\(또는 **리터럴**\)을 할당함으로써 초기 값을 지정합니다. \(리터럴 값은 아래 예시의 `42`, `3.14159`와 같이 코드 자체에서 바로 보이는 값을 말합니다.\)

예를 들어 새로운 상수에 `42`라는 리터럴 값을 자료형 없이 할당한다면, Swift는 초기화하려는 그 수가 정수처럼 생겼으니 상수가 `Int`일 것으로 판단합니다.

```swift
let meaningOfLife = 42
// meaningOfLife는 Int 형이라고 추론됩니다.
```

마찬가지로 부동 소수점 리터럴에 자료형을 명시하지 않으면, Swift는 `Double`로 판단합니다.

```swift
let pi = 3.14159
// pi는 Double 형으로 추론됩니다.
```

Swift는 부동 소수점 수의 자료형을 추론할 때 항상 \(`Float`이 아닌\) `Double`을 선택합니다.

표현식에서 정수와 부동 소수점 리터럴을 서로 더한다면, 의도에 맞게 `Double` 형으로 추론됩니다.

```swift
let anotherPi = 3 + 0.14159
// anotherPi 또한 Double 형으로 추론됩니다.
```

리터럴 값 `3`은 명시적 자료형을 가지고 있지 않습니다. 덧셈에 부동 소수점 리터럴이 포함되어 있다는 점으로부터 `Double`이 유추됩니다.

## 숫자 리터럴

정수 리터럴은 다음과 같은 형식들로 작성될 수 있습니다.

* 접두사 없는 **십**진수
* `0b` 접두사를 가진 **이**진수
* `0x` 접두사를 가진 **십육**진수
* `0o` 접두사를 가진 **팔**진수

다음의 정수 리터럴들은 전부 `17`의 십진 값을 가집니다.

```swift
let decimalInteger = 17
let binaryInteger = 0b10001       // 이진 표기법으로 나타낸 17
let octalInteger = 0o21           // 팔진 표기법으로 타나낸 17
let hexadecimalInteger = 0x11     // 십육진 표기법으로 나타낸 17
```

부동 소수점 리터럴은 \(접두사 없는\) 십진수나 \(`0x` 접두사를 가진\) 십육진수로 나타낼 수 있습니다. 소수점 앞뒤에는 항상 숫자가 있어야 합니다. 십진수 소수는 **지수**를 사용하여 나타낼 수도 있습니다. 대문자나 소문자 `e`로 표시하세요. 십육진수 소수는 항상 지수를 사용해야 하며, 이때는 대문자나 소문자 `p`로 표시하세요.

지수가 `exp`인 십진수는 밑에 10`exp`가 곱해진 수를 나타냅니다.

* `1.25e2`는 1.25 x 102, 즉 `125.0`을 의미합니다.
* `1.25e-2`는 1.25 x 10-2, 즉 `0.0125`를 의미합니다.

지수가 `exp`인 십육진수는 밑에 2`exp`가 곱해진 수를 나타냅니다.

* `0xFp2`는 15 x 22, 즉 `60.0`을 의미합니다.
* `0xFp-2`는 15 x 2-2, 즉 `3.75`를 의미합니다.

아래 부동 소수점 리터럴은 전부 십진 값으로 `12.1875`를 가집니다.

```swift
let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
```

가독성을 높이기 위해 숫자 리터럴에 별도의 형식을 추가할 수 있습니다. 정수나 부동 소수점 수에 `0`이나 밑줄을 추가해보세요. 이런 형식은 리터럴의 값에는 영향을 주지 않습니다.

```swift
let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
```

## 숫자형 변환

코드를 작성할 때, 일반적인 목적의 상수나 변수에는 그 값이 음수가 아님을 알더라도 항상 `Int` 형을 사용하세요. 일반적인 상황에서 항상 기본 정수형을 사용하면 정수형 상수와 변수 서로를 직접 연산할 수 있게 되며 정수 리터럴 값의 추론형과도 일치하게 됩니다.

외부 자료의 데이터의 크기가 명시되어 있다거나, 성능, 메모리 사용 등의 최적화가 특별히 필요한 경우에만 다른 정수형을 사용하세요. 이런 상황에서는 자료형의 크기를 명시하는 것이 예상치 못한 값이 오버플로우하는 것을 파악하거나 사용되는 데이터의 특성을 묵시적으로 나타내는 데 도움을 줄 수 있습니다.

### 정수형 변환

정수형 상수나 변수에 저장할 수 있는 값의 범위는 자료형마다 다릅니다. `Int8` 상수나 변수는 `-128`부터 `127`까지의 값을 저장할 수 있으며, `UInt8` 상수나 변수는 `0`과 `255` 사이의 값을 저장할 수 있습니다. 크기가 정해진 상수나 변수에 맞지 않는 수는 컴파일 시 오류를 일으킵니다.

```swift
let cannotBeNegative: UInt8 = -1
// UInt8은 음수를 저장할 수 없으므로 이것은 오류를 일으킵니다.
let tooBig: Int8 = Int8.max + 1
// Int8은 자신의 최댓값보다 더 큰 수를 저장할 수 없습니다.
// 따라서 이것 역시 오류를 일으킵니다.
```

숫자형마다 저장할 수 있는 값의 범위가 다르므로 상황에 맞게 숫자형 변환을 사용해야만 합니다. 그렇게 하여 숨겨진 변환 오류를 막고 형 변환의 의도를 명시적으로 나타낼 수 있습니다.

특정한 숫자형을 다른 자료형으로 바꾸기 위해서는 바꾸려는 자료형의 수를 새로 생성하면서 동시에 기존의 값으로 초기화하면 됩니다. 아래 예시에서 상수 `twoThousand`는 `UInt16` 형이고 상수 `one`은 `UInt8` 형입니다. 이 둘은 자료형이 달라 바로 서로 더할 수 없습니다. 대신 예시에서는 `UInt16(one)`을 호출하여 새로운 `UInt16`을 만들고 `one`의 값으로 초기화합니다. 그리고 그 값을 원래의 값 대신 사용합니다.

```swift
let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
```

더하는 두 값이 이제는 모두 `UInt16` 형이므로 덧셈이 가능합니다. 결과값\(`twoThousandAndOne`\)은 두 `UInt16` 값의 합이므로 `UInt16` 형으로 추론됩니다.

`SomeType(ofInitialValue)`는 Swift 자료형의 이니셜라이저를 호출하고 초기 값을 넘기는 기본적인 방법입니다. 내부적으로, `UInt16`이 `UInt8` 값을 받는 이니셜라이저를 가지고 있기에 기존의 `UInt8`으로 새로운 `UInt16`을 만들 수 있는 것입니다. 그러니 여기로 **아무** 자료형이나 넘겨줄 수는 없습니다. `UInt16` 이니셜라이저가 지원하는 자료형이어야만 하지요. 기존의 자료형이 \(여러분이 정의한 자료형을 포함하여\) 새로운 자료형을 받아들이도록 이니셜라이저를 확장하려면 [확장](https://github.com/woooil/the-swift-programming-language-in-korean/tree/79d6afaab7856a93228ba8c0f9ed6d4a2c80f4a4/language-guide/extentions.md)을 참고하세요.

### 정수와 부동 소수점 변환

정수와 부동 소수점 숫자형 간의 변환은 반드시 명시해야 합니다.

```swift
let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine
// pi는 3.14159이 되며, Double 형으로 추론됩니다.
```

여기서 상수 `three`의 값은 그대로 쓰이지 않고 `Double` 형의 새로운 값으로 대체되므로 더하는 두 값의 자료형이 같아집니다. 이 변환 과정이 없다면 덧셈이 허용되지 않을 것입니다.

부동 소수점을 정수로 변환하는 과정도 명시적이어야 합니다. 정수형은 `Double`이나 `Float` 값을 이용하여 초기화할 수 있습니다.

```swift
let integerPi = Int(pi)
// integerPi는 3이 되며, Int 형으로 추론됩니다.
```

이런 방식으로 부동 소수점 값이 새로운 정수를 초기화하는 데 쓰일 때는 소수점 이하 자릿수가 모두 버려집니다. 즉, `4.75`는 `4`가 되고, `-3.9`는 `-3`이 됩니다.

> **참고**
>
> 숫자 상수와 변수를 더하는 규칙은 숫자 리터럴을 더하는 규칙과 다릅니다. 리터럴 값 `3`은 리터럴 값 `0.14159`에 바로 더할 수 있습니다. 숫자 리터럴에는 명시적인 자료형이 없기 때문입니다. 리터럴의 자료형은 컴파일러에 의해 평가되는 시점에만 추론됩니다.

## 자료형 별명

**자료형 별명**은 기존의 자료형에 또 다른 이름을 붙이는 것입니다. `typealias` 키워드로 자료형 별명을 정의하세요.

자료형 별명은 이미 존재하는 자료형을 문맥상 더 잘 어울리는 이름으로 참조하고자 할 때 유용합니다. 예를 들면, 외부 자료에서 불러온 특정 크기의 데이터를 다룰 때 말이죠.

```swift
typealias AudioSample = UInt16
```

자료형 별명을 정의하고 나면 어디서든 원래 이름 대신 별명을 사용할 수 있습니다.

```swift
var maxAmplitudeFound = AudioSample.min
// maxAmplitudeFound는 이제 0입니다.
```

여기서는 `UInt16`의 별명으로서 `AudioSample`이 정의되었습니다. 이것은 별명일 뿐이므로 `AudioSample.min`을 호출하면 실제로는 `UInt16.min`이 호출되어 `maxAmplitudeFound` 변수의 초기 값으로 `0`이 저장됩니다.

## 불형

Swift에는 기본적인 **불형**이 존재하며, `Bool`이라고 부릅니다. 불은 그 값으로 참 또는 거짓만을 가질 수 있으므로 **논리 값**이라고도 불립니다. 이 두 가지 불 상수 값으로 Swift는 `true`와 `false`를 지원합니다.

```swift
let orangesAreOrange = true
let turnipsAreDelicious = false
```

`orangesAreOrange`와 `turnipsAreDelicious`은 불 리터럴 값으로 초기화되었다는 사실에 근거해 `Bool` 형으로 추론됩니다. `Int`와 `Double`과 마찬가지로, 상수나 변수를 생성하면서 동시에 `true`나 `false`로 지정한다면, `Bool`이라고 명시할 필요가 없습니다. Swift에서 자료형 추론은 자료형이 알려진 값으로 상수나 변수를 초기화할 때 코드를 더 간결하고 가독성 좋게 만들어줍니다.

불 값은 특히 `if` 구문과 같은 조건문에서 유용합니다.

```swift
if turnipsAreDelicious {
    print("Mmm, tasty turnips!")
} else {
    print("Eww, turnips are horrible")
}
// "Eww, turnips are horrible" 출력
```

`if` 구문 등에서의 조건문은 [제어 흐름](control-flow.md)에서 더 자세히 다루고 있습니다.

Swift의 자료형 안전성은 불이 아닌 값이 `Bool`을 대체하지 못하도록 막습니다. 다음 예시는 컴파일 시간 오류를 일으킵니다.

```swift
let i = 1
if i {
    // 이 예시는 컴파일되지 않고 오류를 일으킬 것입니다.
}
```

그러나 다음 예시는 유효합니다.

```swift
let i = 1
if i == 1 {
    // 이 예시는 성공적으로 컴파일됩니다.
}
```

`i == 1` 비교식의 결과가 `Bool` 형이므로 두 번째 예시는 자료형 검사를 통과합니다. `i == 1`과 같은 비교식은 [기본 연산자](basic-operators.md)에 소개되어 있습니다.

Swift에서의 다른 자료형 안전성 예시와 마찬가지로 이런 방식은 예기치 못한 오류를 방지하고 코드의 의도를 항상 명확하게 해줍니다.

## 튜플

**튜플**은 여러 개의 값들을 하나의 혼합된 값으로 묶습니다. 튜플 안의 값들은 아무 자료형이나 와도 되며, 서로 자료형이 같을 필요도 없습니다.

아래 예시에서 `(404, "Not Found")` 튜플은 **HTTP 상태 코드**를 나타내고 있습니다. HTTP 상태 코드는 웹 페이지를 요청할 때마다 웹 서버가 반환하는 특별한 값입니다. 존재하지 않는 웹 페이지를 요청한다면 `404 Not Found`라는 상태 코드가 반환됩니다.

```swift
let http404Error = (404, "Not Found")
// http404Error는 (Int, String) 형이며, 그 값이 (404, "Not Found")와 같습니다.
```

`(404, "Not Found")` 튜플은 `Int`와 `String`을 묶어 HTTP 상태 코드에게 숫자와 사람이 읽을 수 있는 설명을 각각 제공합니다. 위에서 선언한 튜플은 "`(Int, String)` 형의 튜플"이라고 표현할 수 있습니다.

튜플은 어느 자료형의 조합으로도 만들 수 있으며, 원하는 만큼 다양한 자료형을 포함할 수 있습니다. `(Int, Int, Int)`나 `(String, Bool)`처럼 정말 어떤 자료형으로 조합된 튜플이든 만들 수 있습니다.

튜플의 원소를 각각의 상수나 변수로 **분해**하면 평소대로 접근할 수 있습니다.

```swift
let (statusCode, statusMessage) = http404Error
print("The status code is \(statusCode)")
// "The status code is 404" 출력
print("The status message is \(statusMessage)")
// "The status message is Not Found 출력
```

튜플 값들 중 일부만 필요하다면 나머지 부분은 튜플을 분해할 때 밑줄\(`_`\)을 사용하여 무시하세요.

```swift
let (justTheStatusCode, _) = http404Error
print("The status code is \(justTheStatusCode)")
// "The status code is 404" 출력
```

아니면 `0`부터 시작하는 인덱스 숫자를 이용하여 튜플의 각각의 원소에 접근해보세요.

```swift
print("The status code is \(http404Error.0)")
// "The status code is 404" 출력
print("The status message is \(http404Error.1)")
// "The status message is Not Found" 출력
```

튜플을 정의할 때 각각의 원소마다 이름을 붙일 수도 있습니다.

```swift
let http200Status = (statusCode: 200, description: "OK")
```

원소에 이름을 붙이고 나면 그 원소 값에 접근할 때 원소 이름을 사용할 수 있습니다.

```swift
print("The status code is \(http200Status.statusCode)")
// "The status code is 200" 출력
print("The status message is \(http200Status.description)")
// "The status message is OK" 출력
```

튜플은 함수에서 값을 반환할 때 특히 유용합니다. 웹 페이지를 탐색하려는 함수의 경우 페이지 탐색의 성공이나 실패 여부를 표현하는 데 `(Int, String)` 튜플을 사용할 수 있습니다. 함수가 서로 자료형까지 다른 두 값을 튜플로 반환하는 것이 한 가지 자료형의 한 가지 값을 반환하는 것보다 훨씬 유용한 정보를 줄 수 있습니다. 자세한 정보는 [함수에서의 다중 반환 값](the-basics.md)을 참고하세요.

> **참고**
>
> 튜플은 관련된 값들을 하나로 묶는 데 유용합니다. 복잡한 데이터 구조를 생성하는 데에 적합한 것이 아닙니다. 여러분의 데이터 구조가 더 복잡해질 것 같다면 튜플이 아닌 클래스나 구조체로 구현하세요. 자세한 정보는 [구조체와 클래스](structures-and-classes.md)를 참고하세요.

## 옵셔널

**옵셔널**은 값이 없을 수도 있는 상황에 사용합니다. 옵셔널은 두 가지 가능성을 표현합니다. 하나는 값이 **있으며** 옵셔널을 개봉하여 그 값에 접근할 수 있다는 것이고, 다른 하나는 값이 아예 **없다**는 것입니다.

> **참고**
>
> C나 Objective-C에는 옵셔널이라는 개념이 없습니다. Objective-C에서 그나마 가까운 개념은 객체를 반환해야 할 메서드가 "유효한 객체가 없음"을 나타내는 의미로서 `nil`을 반환할 수 있다는 것입니다. 그러나 이것은 객체에만 적용할 수 있지, 구조체나 기초 C 자료형, 열거형에는 적용할 수 없습니다. 이런 유형의 값들이 없음을 나타내기 위해 Objective-C는 일반적으로 \(`NSNotFound`와 같은\) 특별한 값을 반환합니다. 이런 방식은 검사해야 하는 특별한 값의 존재를, 함수를 호출한 부분이 알고 기억한다고 가정합니다. Swift의 옵셔널을 사용하면 별도의 상수 없이 **말 그대로 모든** 자료형의 값이 없음을 나타낼 수 있습니다.

아래는 옵셔널을 이용하여 값이 없는 상황을 다루는 예시입니다. Swift의 `Int` 형은 `String` 값에서 `Int` 값으로의 변환을 시도하는 이니셜라이저를 가지고 있습니다. 그러나 모든 문자열이 정수로 변환될 수 있는 것은 아닙니다. 문자열 `"123"`은 수 `123`으로 변환할 수 있지만, 문자열 `"hello, world"`는 변환할 마땅한 수가 없습니다.

아래 예시에서 `String`을 `Int`로 변환하는 이니셜라이저를 사용하고 있습니다.

```swift
let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
// convertedNumber은 "Int?", 즉 "옵셔널 Int" 형으로 추론됩니다.
```

이니셜라이저는 실패할 수도 있으므로 `Int`가 아닌 **옵셔널** `Int`를 반환합니다. 옵셔널 `Int`는 `Int` 대신 `Int?`로 표기합니다. 옵셔널 `Int`는 어떤 `Int` 값을 **포함할** 수도 있고 아무 값도 포함하지 **않을** 수도 있습니다. 물음표가 그것을 나타냅니다. \(`Bool` 값이나 `String` 값 등의 다른 값은 포함할 수 없습니다. 오직 `Int`를 포함하거나 아무것도 포함하지 않습니다.\)

### nil

값이 없는 상태는 옵셔널 변수에 `nil`이라는 특별한 값을 할당하여 나타냅니다.

```swift
var serverResponseCode: Int? = 404
// serverResponseCode는 실제 Int 값 404를 가집니다.
serverResponseCode = nil
// serverResponseCode는 이제 아무런 값도 가지지 않습니다.
```

> **참고**
>
> 옵셔널이 아닌 상수나 변수에는 `nil`을 사용할 수 없습니다. 상수나 변수에 대해 특정 조건에서 값이 없음을 나타내려면 항상 적절한 형태의 옵셔널 값을 선언하세요.

기본 값 없이 옵셔널 변수를 정의하면 변수는 자동적으로 `nil`로 설정됩니다.

```swift
var surveyAnswer: String?
// surveyAnswer는 자동으로 nil로 설정됩니다.
```

> **참고**
>
> Swift에서의 `nil`은 Objective-C에서의 `nil`과는 다릅니다. Objective-C에서 `nil`은 존재하지 않는 객체를 가리키는 포인터의 역할입니다. Swift에서는 `nil`이 포인터가 아니라 특정 자료형의 값이 없는 상태를 나타냅니다. 객체형 뿐만 아니라 모든 자료형의 옵셔널이 `nil`로 설정될 수 있습니다.

### If 구문과 강제 개봉

`if` 구문을 사용하여 옵셔널을 `nil`과 비교하여 옵셔널이 값을 포함하고 있는지 여부를 알아낼 수 있습니다. "동등" 연산자 \(`==`\)나 "부등" 연산자 \(`!=`\)를 사용하면 됩니다.

옵셔널이 값을 가지고 있다면, `nil`과 "다르다"고 할 수 있습니다.

```swift
if convertedNumber != nil {
    print("convertedNumber contains some integer value.")
}
// "convertedNumber contains some integer value." 출력
```

옵셔널이 값을 **포함하고** 있다는 것이 확인되면 옵셔널 이름 끝에 느낌표\(`!`\)를 붙여 그 내부의 값에 접근할 수 있습니다. 느낌표는 다음과 같은 의미를 가집니다. "옵셔널이 값을 가지고 있다고 확신한다. 그러니 그 값을 사용하라." 이것을 옵셔널 값의 **강제 개봉**이라고 부릅니다.

```swift
if convertedNumber != nil {
    print("convertedNumber has an integer value of \(convertedNumber!).")
}
// "convertedNumber has an integer value of 123." 출력
```

`if` 구문에 대한 자세한 정보는 [제어 흐름](control-flow.md)에 소개되어 있습니다.

> **참고**
>
> `!`을 사용하여 존재하지 않는 옵셔널 값에 접근하려 하면 런타임 오류가 발생합니다. `!`로 값을 강제 개봉하기 전에 항상 옵셔널에 `nil`이 아닌 값이 들어 있는지 확인하세요.

### 옵셔널 연결

**옵셔널 연결**은 옵셔널이 값을 가지고 있는지 확인하고, 만약 있다면 그 값을 임시 상수나 변수로 사용할 수 있도록 하는 것을 말합니다. 옵셔널 연결을 `if`나 `while` 구문과 함께 사용하면 동작 하나만으로 옵셔널 내부의 값을 검사하고 그 값을 상수나 변수로 추출할 수 있습니다. `if`와 `while` 구문은 [제어 흐름](control-flow.md)에 자세히 나와 있습니다.

`if` 구문에서의 옵셔널 연결은 다음처럼 작성하세요.

```swift
if let constantName = someOptional {
    statements
}
```

이제 [옵셔널](the-basics.md#undefined-11) 부분의 `possibleNumber` 예시를 강제 개봉 대신 옵셔널 연결을 사용하여 다시 작성할 수 있습니다.

```swift
if let actualNumber = Int(possibleNumber) {
    print("The string \"\(possibleNumber)\" has an integer value of \(actualNumber)")
} else {
    print("The string \"\(possibleNumber)\" couldn't be converted to an integer")
}
// "The string "123" has an integer value of 123" 출력
```

이 코드는 이렇게 읽을 수 있습니다.

"`Int(possibleNumber)`가 반환한 옵셔널 `Int`가 값을 가지고 있으면 그 값을 새로운 상수 `actualNumber`에 저장하여라."

변환이 잘 이루어졌다면 `if` 구문의 첫 번째 분기 내에서 `actualNumber` 상수를 사용할 수 있게 됩니다. 이미 옵셔널이 **봉인하고 있던** 값으로 초기화된 상태이므로 값에 접근하기 위해 `!` 접미사를 붙일 필요가 없습니다. 이 예시에서는 `actualNumber`가 단순히 변환의 결과를 출력하는 데 사용되었습니다.

옵셔널 연결에는 상수와 변수를 모두 사용할 수 있습니다. `if` 구문의 첫 분기에서 `actualNumber`의 값을 조작하고 싶다면 `if var actualNumber`로 작성하세요. 옵셔널 안에 있는 값을 상수가 아닌 변수로 사용할 수 있게 됩니다.

하나의 `if` 구문에 옵셔널 연결과 불 조건식을 쉼표로 구분하여 여러 개 삽입할 수 있습니다. 옵셔널 연결에 쓰인 값이 하나라도 `nil`이거나 불 조건식 중에 하나라도 `false`가 있다면 `if` 구문의 조건식 전체가 `false`로 평가됩니다. 다음 두 `if` 구문은 서로 동등한 표현입니다.

```swift
if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 {
    print("\(firstNumber) < \(secondNumber) < 100")
}
// "4 < 42 < 100" 출력

if let firstNumber = Int("4") {
    if let secondNumber = Int("42") {
        if firstNumber < secondNumber && secondNumber < 100 {
            print("\(firstNumber) < \(secondNumber) < 100")
        }
    }
}
// "4 < 42 < 100" 출력
```

> **참고**
>
> `if` 구문에서 옵셔널 연결로 생성한 상수와 변수는 `if` 구문의 몸체 내에서만 사용할 수 있습니다. 이와 다르게 `guard` 구문으로 생성된 상수와 변수는 `guard` 구문을 따르는 모든 코드에서 사용할 수 있습니다. 자세한 정보는 [빠른 종료](the-basics.md)를 참고하세요.

### 묵시적 개봉 옵셔널

상술하였듯이 옵셔널은 상수나 변수에 값이 없을 수도 있음을 나타냅니다. `if` 구문에 의해 옵셔널의 값이 존재하는지 검사하고, 값이 존재하는 경우에 한해 옵셔널 연결로 값을 개봉하고 접근할 수 있습니다.

프로그램 구조상, 옵셔널 값이 한 번 설정되고 난 뒤로는 옵셔널이 **항상** 값을 가지고 있음이 확실한 경우도 있습니다. 이런 경우에는 항상 값이 존재한다는 가정을 안전하게 내릴 수 있습니다. 따라서 옵셔널 값에 접근할 때마다 값을 검사하고 개봉하는 과정을 생략하는 것이 더 유용합니다.

이런 종류의 옵셔널은 **묵시적 개봉 옵셔널**이라고 부릅니다. 옵셔널의 자료형 뒤에 물음표\(`String?`\)이 아닌 느낌표\(`String!`\)을 적어 묵시적 개봉 옵셔널임을 나타내세요. 옵셔널을 사용할 때 말고, 옵셔널을 선언할 때 자료형 뒤에 느낌표를 적으세요.

옵셔널이 처음 정의된 순간과 그 이후의 모든 시점에 그 값이 분명히 존재한다면 묵시적 개봉 옵셔널이 유용합니다. Swift에서의 묵시적 개봉 옵셔널의 가장 주요한 용도는 클래스 초기화에서입니다. 자세한 정보는 [비소유 참조와 묵시적 개봉 옵셔널 프로퍼티](the-basics.md)를 참고하세요.

내부적으로는 묵시적 개봉 옵셔널이 일반적인 옵셔널과 동일하지만, 값에 접근할 때는 옵셔널이 아닌 값처럼 개봉하지 않고 사용할 수 있습니다. 다음 예시는 옵셔널 문자열과 묵시적 개봉 옵셔널 문자열에 각각 접근하면서 둘의 차이를 보여주고 있습니다.

```swift
let possibleString: String? = "An optional string."
let forcedString: String = possibleString! // 느낌표가 필요합니다.

let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString // 느낌표가 필요 없습니다.
```

묵시적 개봉 옵셔널은 필요에 따라 강제로 개봉하라는 허락을 내어주는 것으로 생각해도 좋습니다. 묵시적 개봉 옵셔널을 사용할 때 Swift는 먼저 그 값을 일반적인 옵셔널 값처럼 다루려고 시도합니다. 그리고 옵셔널로서 사용할 수 없다면 값을 강제 개봉합니다. 위의 예시에서는 `implicitString`이 옵셔널이 아닌 `String` 형이라고 명시하고 있으므로 `assumedString`을 `implicitString`에 할당하기 전 강제로 개봉합니다. 아래 예시에서는 `optionalString`에 명시적인 자료형이 없으므로 일반적인 옵셔널이 됩니다.

```swift
let optionalString = assumedString
// optionalString은 "String?" 형이고 강제 개봉되지 않습니다.
```

명시적 개봉 옵셔널이 `nil`이고 그 밀봉된 값에 접근하려 하면 런타임 오류가 발생합니다. 이때 결과는 값을 가지고 있지 않은 일반적인 옵셔널 뒤에 느낌표를 붙일 때와 같습니다.

명시적 개봉 옵셔널이 `nil`인지 검사하는 방법은 일반적인 옵셔널에서와 동일합니다.

```swift
if assumedString != nil {
    print(assumedString!)
}
// "An implicitly unwrapped optional string." 출력
```

명시적 개봉 옵셔널을 옵셔널 연결과 함께 사용하면 한 문장에서 값을 검사하고 개봉할 수도 있습니다.

```swift
if let definiteString = assumedString {
    print(definiteString)
}
// "An implicitly unwrapped optional string." 출력
```

> **참고**
>
> 이후에 `nil`이 될 수 있는 변수에는 명시적 개봉 옵셔널을 사용하지 마세요. 변수를 사용하는 동안 `nil` 값을 검사해야 하는 경우가 생긴다면 항상 일반적인 옵셔널형을 사용하세요.

## 오류 처리

프로그램이 실행되는 중 마주할 수 있는 오류 상황에 대응하는 데 **오류 처리**를 사용하세요.

옵셔널은 값의 존재 여부를 이용하여 함수가 성공했는지 실패했는지 알려주었습니다. 이와 다르게 오류 처리는 실패의 내부 원인을 판단하고 필요에 따라 프로그램의 다른 부분으로까지 오류 내용을 전달합니다.

함수는 오류 상황을 맞닥뜨리면 오류를 **던집니다.** 그 함수를 호출한 부분에서는 오류를 **잡고** 적절하게 대응할 수 있습니다.

```swift
func canThrowAnError() throws {
    // 이 함수는 오류를 던질 가능성이 있습니다.
}
```

함수 선언에 `throw` 키워드를 추가하여 그 함수가 오류를 던질 수 있음을 알립니다. 오류를 던질 수 있는 함수를 호출할 때는 표현식 앞에 `try` 키워드를 붙이세요.

Swift는 오류가 `catch` 절에 의해 처리될 때까지 오류를 현재 영역 밖으로 계속 전달합니다.

```swift
do {
    try canThrowAnError()
    // 던져지는 오류가 없습니다.
} catch {
    // 오류가 던저집니다.
}
```

`do` 구문은 영역을 새롭게 구분하여 오류가 하나 이상의 `catch` 절로 전달되도록 합니다.

다양한 오류 상황에 대응할 수 있는 오류 처리의 예시입니다.

```swift
func makeASandwich() throws {
    // ...
}

do {
    try makeASandwich()
    eatASandwich()
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)
}
```

이 예시에서 `makeASandwich()` 함수는 사용할 수 있는 깨끗한 접시가 없거나 빠진 재료가 있을 경우에 오류를 던집니다. `makeASandwich()`가 오류를 던질 수 있으므로 함수 호출은 `try` 표현식으로 감싸집니다. 함수 호출을 `do` 구문으로 감쌈에 따라 던져지는 모든 오류는 준비된 `catch` 절로 전달됩니다.

아무 오류도 던져지지 않으면 `eatASandwich()` 함수가 호출됩니다. 오류가 던져지고 그것이 `SandwichError.outOfCleanDishes` 케이스와 일치한다면, `washDishes()` 함수가 호출될 것입니다. 오류가 던져지고 그것이 `SandwichError.missingIngredients` 케이스와 일치한다면, `buyGroceries(_:)` 함수가 `catch` 패턴에서 얻어낸 연관 `[String]` 값과 함께 호출될 것입니다.

오류 던지기와 잡기, 전달하기는 [오류 처리](error-handling.md)에서 훨씬 자세하게 다루고 있습니다.

## 주장과 전제 조건

**주장**과 **전제 조건**은 런타임에서 실시되는 검사입니다. 이 둘을 이용하면 이어지는 코드를 실행하기 전에 미리 필수적인 조건들이 만족하는지 확인할 수 있습니다. 주장문과 전제 조건문의 불 조건식이 `true`라면 평상시처럼 코드가 계속 실행됩니다. 조건식이 `false`라면 프로그램은 무효한 상태가 됩니다. 코드 실행이 끝나고 앱이 종료됩니다.

주장문이나 전제 조건문을 이용하여 가정이나 예상을 코드로 표현하세요. 주장은 개발 단계에서 실수와 잘못된 가정을 찾도록 도와줍니다. 전제 조건은 프로덕션 시 문제를 파악하도록 도와줍니다.

주장과 전제 조건은 런타임 시 예상을 검증할 뿐만 아니라, 코드 내에서 유용한 문서 형식이 됩니다. [오류 처리](the-basics.md#undefined-12)에서 논의한 오류 상황과 다르게 주장문과 전제 조건문은 복구가 가능하거나 예측할 수 있는 오류에 사용하는 것이 아닙니다. 주장문이나 전제 조건문의 실패는 프로그램의 상태가 무효하다는 것을 의미합니다. 실패한 주장문을 잡을 방법이 없습니다.

주장문과 전제 조건문을 사용한다고 코드에서 무효한 상황이 발생하지 않는 것이 아닙니다. 그러나 이들을 사용하여 유효한 데이터와 상태를 강조하게 되면, 무효한 상태가 되었을 때도 앱이 예상과 더 가깝게 종료되며 문제를 찾고 디버그하기가 쉬워집니다. 무효한 상태가 감지된 즉시 실행을 종료하여 무효한 상태로 인한 손상을 최대한 방지할 수도 있습니다.

주장문과 전제 조건문의 차이는 이들이 검사 받는 시기에 있습니다. 주장문은 디버그 빌드에서만 검사되는 반면, 전제 조건문은 디버그 빌드와 프로덕션 빌드 모두에서 검사됩니다. 프로덕션 빌드에서 주장문 내의 조건문은 평가되지 않습니다. 즉, 개발 과정에서 원하는 만큼 주장문을 넣어도 프로덕션 성능에는 영향을 미치지 않습니다.

### 디버깅에서의 주장

주장문은 Swift 표준 라이브러리에 있는 `assert(_:_:file:line:)` 함수를 호출하여 작성할 수 있습니다. 이 함수로 `true`인지 `false`인지 평가하려는 표현식과 표현식의 결과가 `false`일 때 화면에 표시할 메시지를 전달합니다. 예를 들면 다음과 같습니다.

```swift
let age = -3
assert(age >= 0, "A person's age can't be less than zero.")
// -3은 >= 0이 아니므로 이 주장문은 실패합니다.
```

이 예시에서는 `age >= 0`이면, 즉 `age`의 값이 음이 아니면 `true`로 평가되어 코드 실행이 이어집니다. 위에서처럼 `age`의 값이 음이면 `age >= 0`이 `false`가 되어 주장문이 실패하고, 앱이 종료됩니다.

주장문의 메시지를 생략하고 조건만 계속 반복할 수도 있습니다.

```swift
assert(age >= 0)
```

코드에서 이미 조건을 검사했다면, `assertionFailure(_:file:line:)` 함수를 사용하여 주장이 실패했음을 나타내세요. 예를 들면 이런 식입니다.

```swift
if age > 10 {
    print("You can ride the roller-coaster or the ferris wheel.")
} else if age >= 0 {
    print("You can ride the ferris wheel.")
} else {
    assertionFailure("A person's age can't be less than zero.")
}
```

### 전제 조건 강제

코드가 계속 실행되기 위해서는 거짓일 가능성을 가진 어떤 조건문이 **반드시** 참이어야만 한다면, 항상 전제 조건문을 사용하세요. 첨자가 범위를 벗어나지 않았는지, 함수가 유효한 값을 받았는지, 전제 조건문을 사용하여 검사하세요.

전제 조건문은 `precondition(_:_:file:line:)` 함수를 호출하여 작성하세요. `true`인지 `false`인지 평가하려는 표현식과 표현식의 결과가 `false`일 때 화면에 표시할 메시지를 전달하세요. 예를 들면 다음과 같습니다.

```swift
// 첨자의 구현에서...
precondition(index > 0, "Index must be greater than zero.")
```

`preconditionFailure(_:file:line:)` 함수를 호출하면 실패가 발생했음을 나타낼 수 있습니다. 예를 들어 유효한 입력 데이터들이라면 모두 스위치의 \(`default`가 아닌\) 지정된 케이스에 의해 처리되어야 하는 상황에서 `default` 케이스가 실행됐다면, 실패가 발생한 것이겠지요.

> **참고**
>
> 언체크 모드\(`-0unchecked`\)로 컴파일하면 전제 조건문이 검사되지 않습니다. 컴파일러는 전제 조건문이 항상 참이라고 가정하고 코드를 최적화합니다. 그러나 `fatalError(_:file:line:)` 함수는 최적화 설정과 무관하게 항상 실행을 중단합니다.
>
> 프로토타입이나 초기 개발 단계에서 `fatalError(_:file:line:)` 함수를 사용할 수 있습니다. 아직 완전히 구현되지 않은 기능의 스텁을 제작할 때는 `fatalError("Unimplemented")`라고 작성해보세요. 이런 치명적인 오류는 주장이나 전제 조건과 다르게 절대 최적화되지 않습니다. 그러니 스텁 구현에서도 실행이 중단되리라 확신할 수 있습니다.

